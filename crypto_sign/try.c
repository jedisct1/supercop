/*
 * crypto_sign/try.c version 20240530
 * D. J. Bernstein
 * Public domain.
 * Auto-generated by trygen.py; do not edit.
 */

#include "crypto_sign.h"
#include "try.h"
#include "randombytes.h"

const char *primitiveimplementation = crypto_sign_IMPLEMENTATION;

#define TUNE_BYTES 1536
#ifdef SMALL
#define MAXTEST_BYTES 128
#else
#define MAXTEST_BYTES 4096
#endif
#ifdef TIMECOP
#define LOOPS TIMECOP_LOOPS
#else
#ifdef SMALL
#define LOOPS 8
#else
#define LOOPS 64
#endif
#endif

#include "test-loops.inc"

static unsigned char *p;
static unsigned char *s;
static unsigned char *m;
static unsigned char *c;
static unsigned char *t;
static unsigned char *p2;
static unsigned char *s2;
static unsigned char *m2;
static unsigned char *c2;
static unsigned char *t2;
#define plen crypto_sign_PUBLICKEYBYTES
#define slen crypto_sign_SECRETKEYBYTES
unsigned long long mlen;
unsigned long long clen;
unsigned long long tlen;

void preallocate(void)
{
#ifdef RAND_R_PRNG_NOT_SEEDED
  RAND_status();
#endif
}

void allocate(void)
{
  unsigned long long alloclen = 0;
  if (alloclen < TUNE_BYTES + crypto_sign_BYTES) alloclen = TUNE_BYTES + crypto_sign_BYTES;
  if (alloclen < MAXTEST_BYTES + crypto_sign_BYTES) alloclen = MAXTEST_BYTES + crypto_sign_BYTES;
  if (alloclen < crypto_sign_PUBLICKEYBYTES) alloclen = crypto_sign_PUBLICKEYBYTES;
  if (alloclen < crypto_sign_SECRETKEYBYTES) alloclen = crypto_sign_SECRETKEYBYTES;
  p = alignedcalloc(alloclen);
  s = alignedcalloc(alloclen);
  m = alignedcalloc(alloclen);
  c = alignedcalloc(alloclen);
  t = alignedcalloc(alloclen);
  p2 = alignedcalloc(alloclen);
  s2 = alignedcalloc(alloclen);
  m2 = alignedcalloc(alloclen);
  c2 = alignedcalloc(alloclen);
  t2 = alignedcalloc(alloclen);
}

void unalign(void)
{
  ++p;
  ++s;
  ++m;
  ++c;
  ++t;
  ++p2;
  ++s2;
  ++m2;
  ++c2;
  ++t2;
}

void realign(void)
{
  --p;
  --s;
  --m;
  --c;
  --t;
  --p2;
  --s2;
  --m2;
  --c2;
  --t2;
}

void predoit(void)
{
  crypto_sign_keypair(p,s);
  unpoison(p,crypto_sign_PUBLICKEYBYTES);
  mlen = TUNE_BYTES;
  clen = 0;
  randombytes(m,mlen);
}

void doit(void)
{
  crypto_sign(c,&clen,m,mlen,s);
  unpoison(c,clen);
  crypto_sign_open(t,&tlen,c,clen,p);
}

void test(void)
{
  unsigned long long loop;
  int result;
  
  for (loop = 0;loop < LOOPS;++loop) {
    mlen = myrandom() % (MAXTEST_BYTES + 1);
    
    output_prepare(p2,p,plen);
    output_prepare(s2,s,slen);
    result = crypto_sign_keypair(p,s);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_sign_keypair returns nonzero");
    unpoison(p,plen);
    unpoison(s,slen);
    checksum(p,plen);
    checksum(s,slen);
    output_compare(p2,p,plen,"crypto_sign_keypair");
    output_compare(s2,s,slen,"crypto_sign_keypair");
    
    clen = mlen + crypto_sign_BYTES;
    output_prepare(c2,c,clen);
    input_prepare(m2,m,mlen);
    memcpy(s2,s,slen);
    double_canary(s2,s,slen);
    poison(m,mlen);
    poison(s,slen);
    result = crypto_sign(c,&clen,m,mlen,s);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_sign returns nonzero");
    unpoison(c,clen);
    unpoison(m,mlen);
    unpoison(s,slen);
    if (clen < mlen) fail("crypto_sign returns smaller output than input");
    if (clen > mlen + crypto_sign_BYTES) fail("crypto_sign returns more than crypto_sign_BYTES extra bytes");
    checksum(c,clen);
    output_compare(c2,c,clen,"crypto_sign");
    input_compare(m2,m,mlen,"crypto_sign");
    input_compare(s2,s,slen,"crypto_sign");
    
#if crypto_sign_DETERMINISTIC == 1
    double_canary(c2,c,clen);
    double_canary(m2,m,mlen);
    double_canary(s2,s,slen);
    poison(m2,mlen);
    poison(s2,slen);
    result = crypto_sign(c2,&clen,m2,mlen,s2);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_sign returns nonzero");
    unpoison(c2,clen);
    unpoison(m2,mlen);
    unpoison(s2,slen);
    if (memcmp(c2,c,clen) != 0) fail("crypto_sign is nondeterministic");
#endif
    
#if crypto_sign_DETERMINISTIC == 1
    double_canary(c2,c,clen);
    double_canary(m2,m,mlen);
    double_canary(s2,s,slen);
    poison(m2,mlen);
    poison(s,slen);
    result = crypto_sign(m2,&clen,m2,mlen,s);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_sign with m=c overlap returns nonzero");
    unpoison(m2,clen);
    unpoison(s,slen);
    if (memcmp(m2,c,clen) != 0) fail("crypto_sign does not handle m=c overlap");
    memcpy(m2,m,mlen);
    poison(m,mlen);
    poison(s2,slen);
    result = crypto_sign(s2,&clen,m,mlen,s2);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_sign with s=c overlap returns nonzero");
    unpoison(s2,clen);
    unpoison(m,mlen);
    if (memcmp(s2,c,clen) != 0) fail("crypto_sign does not handle s=c overlap");
    memcpy(s2,s,slen);
#endif
    
    tlen = clen;
    output_prepare(t2,t,tlen);
    memcpy(c2,c,clen);
    double_canary(c2,c,clen);
    memcpy(p2,p,plen);
    double_canary(p2,p,plen);
    unpoison(c,clen);
    unpoison(p,plen);
    result = crypto_sign_open(t,&tlen,c,clen,p);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_sign_open returns nonzero");
    unpoison(t,tlen);
    unpoison(c,clen);
    unpoison(p,plen);
    if (tlen != mlen) fail("crypto_sign_open does not match mlen");
    if (memcmp(t,m,mlen) != 0) fail("crypto_sign_open does not match m");
    checksum(t,tlen);
    output_compare(t2,t,clen,"crypto_sign_open");
    input_compare(c2,c,clen,"crypto_sign_open");
    input_compare(p2,p,plen,"crypto_sign_open");
    
    double_canary(t2,t,tlen);
    double_canary(c2,c,clen);
    double_canary(p2,p,plen);
    unpoison(c2,clen);
    unpoison(p2,plen);
    result = crypto_sign_open(t2,&tlen,c2,clen,p2);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_sign_open returns nonzero");
    unpoison(t2,tlen);
    unpoison(c2,clen);
    unpoison(p2,plen);
    if (memcmp(t2,t,tlen) != 0) fail("crypto_sign_open is nondeterministic");
    
    double_canary(t2,t,tlen);
    double_canary(c2,c,clen);
    double_canary(p2,p,plen);
    unpoison(c2,clen);
    unpoison(p,plen);
    result = crypto_sign_open(c2,&tlen,c2,clen,p);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_sign_open with c=t overlap returns nonzero");
    unpoison(c2,tlen);
    unpoison(p,plen);
    if (memcmp(c2,t,tlen) != 0) fail("crypto_sign_open does not handle c=t overlap");
    memcpy(c2,c,clen);
    unpoison(c,clen);
    unpoison(p2,plen);
    result = crypto_sign_open(p2,&tlen,c,clen,p2);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_sign_open with p=t overlap returns nonzero");
    unpoison(p2,tlen);
    unpoison(c,clen);
    if (memcmp(p2,t,tlen) != 0) fail("crypto_sign_open does not handle p=t overlap");
    memcpy(p2,p,plen);
    
    c[myrandom() % clen] += 1 + (myrandom() % 255);
    if (crypto_sign_open(t,&tlen,c,clen,p) == 0)
      if ((tlen != mlen) || (memcmp(t,m,mlen) != 0))
        fail("crypto_sign_open allows trivial forgeries");
    c[myrandom() % clen] += 1 + (myrandom() % 255);
    if (crypto_sign_open(t,&tlen,c,clen,p) == 0)
      if ((tlen != mlen) || (memcmp(t,m,mlen) != 0))
        fail("crypto_sign_open allows trivial forgeries");
    c[myrandom() % clen] += 1 + (myrandom() % 255);
    if (crypto_sign_open(t,&tlen,c,clen,p) == 0)
      if ((tlen != mlen) || (memcmp(t,m,mlen) != 0))
        fail("crypto_sign_open allows trivial forgeries");
  }
#include "test-more.inc"
}
