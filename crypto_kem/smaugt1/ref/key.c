#include "key.h"
#include "poly.h"
#include "randombytes.h"
#include <stdlib.h>
#include <string.h>

/*************************************************
 * Name:        genAx
 *
 * Description: Deterministically generate public matrix A from a seed.
 *              Entries of the A are polynomials that look uniformly random.
 *
 * Arguments:   - uint16_t *A: pointer to output matrix A
 *              - uint8_t *seed: pointer to input seed (of length
 *                                     PKSEED_BYTES)
 **************************************************/
void genAx(polyvec A[MODULE_RANK], const uint8_t seed[PKSEED_BYTES]) {
    unsigned int i, j;
    uint8_t buf[PKPOLY_BYTES] = {0}, tmpseed[PKSEED_BYTES + 2];
    memcpy(tmpseed, seed, PKSEED_BYTES);
    for (i = 0; i < MODULE_RANK; i++) {
        for (j = 0; j < MODULE_RANK; j++) {
            tmpseed[32] = i;
            tmpseed[33] = j;
            shake128(buf, PKPOLY_BYTES, tmpseed, PKSEED_BYTES + 2);
            bytes_to_Rq(&A[i].vec[j], buf);
        }
    }
}

/*************************************************
 * Name:        genBx
 *
 * Description: Generate public vector b from a matrix A, vector s and noise e.
 *              Random noise e is generated by Gaussian sampling.
 *
 * Arguments:   - uint16_t *b: pointer to output vector b
 *              - uint16_t *A: pointer to input matrix A
 *              - uint8_t *s: pointer to input vector s
 *              - uint8_t *e_seed: pointer to input seed of error (of
 *                                     length crypto_BYTES)
 **************************************************/
void genBx(polyvec *b, const polyvec A[MODULE_RANK], const polyvec *s,
           const uint8_t e_seed[crypto_BYTES]) {
    // b = e
    addGaussianErrorVec(b, e_seed);

    // b = -a * s + e
    matrix_vec_mult_sub(b, A, s);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*************************************************
 * Name:        genSx_vec
 *
 * Description: Generate a vector of secret sparse polynomial s(x) from a seed.
 *
 * Arguments:   - secret_key *sk: pointer to output private key
 *              - const uint8_t *seed: pointer to a input seed of s(x) (of
 *                                     length crypto_BYTES)
 **************************************************/
void genSx_vec(secret_key *sk, const uint8_t seed[crypto_BYTES]) {
    unsigned int i, j;
    uint8_t extseed[crypto_BYTES + 2] = {0};
    memcpy(extseed, seed, crypto_BYTES);

    for (i = 0; i < MODULE_RANK; ++i) {
        extseed[crypto_BYTES] = i * MODULE_RANK;
        j = 0;
        do {
            extseed[crypto_BYTES + 1] = j;
            j += 1;
        } while(hwt(sk->vec[i].coeffs, extseed));
    }
}

/*************************************************
 * Name:        genPubkey
 *
 * Description: Generate public key correspending to private key.
 *
 * Arguments:   - public_key *pk: pointer to output public key
 *              - secret_key *sk: pointer to input private key
 *              - const uint8_t *err_seed: pointer to input seed of error (of
 *                                     length crypto_BYTES)
 **************************************************/
void genPubkey(public_key *pk, const secret_key *sk,
               const uint8_t err_seed[crypto_BYTES]) {
    genAx(pk->A, pk->seed);

    memset(&(pk->b), 0, sizeof(uint16_t) * LWE_N);
    // Initialized at addGaussian, Unnecessary
    genBx(&(pk->b), pk->A, sk, err_seed);
}
