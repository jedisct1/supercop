/*
 * crypto_dh/try.c version 20240530
 * D. J. Bernstein
 * Public domain.
 * Auto-generated by trygen.py; do not edit.
 */

#include "crypto_dh.h"
#include "try.h"

const char *primitiveimplementation = crypto_dh_IMPLEMENTATION;

#ifdef TIMECOP
#define LOOPS TIMECOP_LOOPS
#else
#ifdef SMALL
#define LOOPS 64
#else
#define LOOPS 512
#endif
#endif

#include "test-loops.inc"

static unsigned char *a;
static unsigned char *b;
static unsigned char *c;
static unsigned char *d;
static unsigned char *e;
static unsigned char *f;
static unsigned char *a2;
static unsigned char *b2;
static unsigned char *c2;
static unsigned char *d2;
static unsigned char *e2;
static unsigned char *f2;
#define alen crypto_dh_SECRETKEYBYTES
#define blen crypto_dh_SECRETKEYBYTES
#define clen crypto_dh_PUBLICKEYBYTES
#define dlen crypto_dh_PUBLICKEYBYTES
#define elen crypto_dh_BYTES
#define flen crypto_dh_BYTES

void preallocate(void)
{
#ifdef RAND_R_PRNG_NOT_SEEDED
  RAND_status();
#endif
}

void allocate(void)
{
  unsigned long long alloclen = 0;
  if (alloclen < crypto_dh_SECRETKEYBYTES) alloclen = crypto_dh_SECRETKEYBYTES;
  if (alloclen < crypto_dh_SECRETKEYBYTES) alloclen = crypto_dh_SECRETKEYBYTES;
  if (alloclen < crypto_dh_PUBLICKEYBYTES) alloclen = crypto_dh_PUBLICKEYBYTES;
  if (alloclen < crypto_dh_PUBLICKEYBYTES) alloclen = crypto_dh_PUBLICKEYBYTES;
  if (alloclen < crypto_dh_BYTES) alloclen = crypto_dh_BYTES;
  if (alloclen < crypto_dh_BYTES) alloclen = crypto_dh_BYTES;
  a = alignedcalloc(alloclen);
  b = alignedcalloc(alloclen);
  c = alignedcalloc(alloclen);
  d = alignedcalloc(alloclen);
  e = alignedcalloc(alloclen);
  f = alignedcalloc(alloclen);
  a2 = alignedcalloc(alloclen);
  b2 = alignedcalloc(alloclen);
  c2 = alignedcalloc(alloclen);
  d2 = alignedcalloc(alloclen);
  e2 = alignedcalloc(alloclen);
  f2 = alignedcalloc(alloclen);
}

void unalign(void)
{
  ++a;
  ++b;
  ++c;
  ++d;
  ++e;
  ++f;
  ++a2;
  ++b2;
  ++c2;
  ++d2;
  ++e2;
  ++f2;
}

void realign(void)
{
  --a;
  --b;
  --c;
  --d;
  --e;
  --f;
  --a2;
  --b2;
  --c2;
  --d2;
  --e2;
  --f2;
}

void predoit(void)
{
}

void doit(void)
{
  crypto_dh_keypair(c,a);
  crypto_dh_keypair(d,b);
  unpoison(c,crypto_dh_PUBLICKEYBYTES);
  unpoison(d,crypto_dh_PUBLICKEYBYTES);
  crypto_dh(e,d,a);
  crypto_dh(f,c,b);
}

void test(void)
{
  unsigned long long loop;
  int result;
  
  for (loop = 0;loop < LOOPS;++loop) {
    
    output_prepare(c2,c,clen);
    output_prepare(a2,a,alen);
    result = crypto_dh_keypair(c,a);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh_keypair returns nonzero");
    unpoison(c,clen);
    unpoison(a,alen);
    checksum(c,clen);
    checksum(a,alen);
    output_compare(c2,c,clen,"crypto_dh_keypair");
    output_compare(a2,a,alen,"crypto_dh_keypair");
    
    output_prepare(d2,d,dlen);
    output_prepare(b2,b,blen);
    result = crypto_dh_keypair(d,b);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh_keypair returns nonzero");
    unpoison(d,dlen);
    unpoison(b,blen);
    checksum(d,dlen);
    checksum(b,blen);
    output_compare(d2,d,dlen,"crypto_dh_keypair");
    output_compare(b2,b,blen,"crypto_dh_keypair");
    
    output_prepare(e2,e,elen);
    memcpy(d2,d,dlen);
    double_canary(d2,d,dlen);
    memcpy(a2,a,alen);
    double_canary(a2,a,alen);
    unpoison(d,dlen);
    poison(a,alen);
    result = crypto_dh(e,d,a);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh returns nonzero");
    unpoison(e,elen);
    unpoison(d,dlen);
    unpoison(a,alen);
    checksum(e,elen);
    output_compare(e2,e,elen,"crypto_dh");
    input_compare(d2,d,dlen,"crypto_dh");
    input_compare(a2,a,alen,"crypto_dh");
    
    double_canary(e2,e,elen);
    double_canary(d2,d,dlen);
    double_canary(a2,a,alen);
    unpoison(d2,dlen);
    poison(a2,alen);
    result = crypto_dh(e2,d2,a2);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh returns nonzero");
    unpoison(e2,elen);
    unpoison(d2,dlen);
    unpoison(a2,alen);
    if (memcmp(e2,e,elen) != 0) fail("crypto_dh is nondeterministic");
    
    double_canary(e2,e,elen);
    double_canary(d2,d,dlen);
    double_canary(a2,a,alen);
    unpoison(d2,dlen);
    poison(a,alen);
    result = crypto_dh(d2,d2,a);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh with d=e overlap returns nonzero");
    unpoison(d2,elen);
    unpoison(a,alen);
    if (memcmp(d2,e,elen) != 0) fail("crypto_dh does not handle d=e overlap");
    memcpy(d2,d,dlen);
    unpoison(d,dlen);
    poison(a2,alen);
    result = crypto_dh(a2,d,a2);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh with a=e overlap returns nonzero");
    unpoison(a2,elen);
    unpoison(d,dlen);
    if (memcmp(a2,e,elen) != 0) fail("crypto_dh does not handle a=e overlap");
    memcpy(a2,a,alen);
    
    output_prepare(f2,f,flen);
    memcpy(c2,c,clen);
    double_canary(c2,c,clen);
    memcpy(b2,b,blen);
    double_canary(b2,b,blen);
    unpoison(c,clen);
    poison(b,blen);
    result = crypto_dh(f,c,b);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh returns nonzero");
    unpoison(f,flen);
    unpoison(c,clen);
    unpoison(b,blen);
    checksum(f,flen);
    output_compare(f2,f,flen,"crypto_dh");
    input_compare(c2,c,clen,"crypto_dh");
    input_compare(b2,b,blen,"crypto_dh");
    
    double_canary(f2,f,flen);
    double_canary(c2,c,clen);
    double_canary(b2,b,blen);
    unpoison(c2,clen);
    poison(b2,blen);
    result = crypto_dh(f2,c2,b2);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh returns nonzero");
    unpoison(f2,flen);
    unpoison(c2,clen);
    unpoison(b2,blen);
    if (memcmp(f2,f,flen) != 0) fail("crypto_dh is nondeterministic");
    
    double_canary(f2,f,flen);
    double_canary(c2,c,clen);
    double_canary(b2,b,blen);
    unpoison(c2,clen);
    poison(b,blen);
    result = crypto_dh(c2,c2,b);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh with c=f overlap returns nonzero");
    unpoison(c2,flen);
    unpoison(b,blen);
    if (memcmp(c2,f,flen) != 0) fail("crypto_dh does not handle c=f overlap");
    memcpy(c2,c,clen);
    unpoison(c,clen);
    poison(b2,blen);
    result = crypto_dh(b2,c,b2);
    unpoison(&result,sizeof result);
    if (result != 0) fail("crypto_dh with b=f overlap returns nonzero");
    unpoison(b2,flen);
    unpoison(c,clen);
    if (memcmp(b2,f,flen) != 0) fail("crypto_dh does not handle b=f overlap");
    memcpy(b2,b,blen);
    
    if (memcmp(f,e,elen) != 0) fail("crypto_dh not associative");
  }
#include "test-more.inc"
}
